{"version":3,"names":[],"mappings":"","sources":["linter.js"],"sourcesContent":["const WARNING_CODE = `WARNING.`;\nconst TEXT_CODE = `TEXT.`;\nconst TEXT_BLOCK = `text`;\nconst HEADING_1_BLOCK = `h1`;\nconst HEADING_2_BLOCK = `h2`;\nconst HEADING_3_BLOCK = `h3`;\nconst BUTTON_BLOCK = `button`;\nconst PLACEHOLDER_BLOCK = `placeholder`;\n\nconst ERROR_CODES = [\n  {\n    warning: `WARNING.`,\n    codes: [\n      {\n        text_size: `TEXT_SIZES_SHOULD_BE_EQUAL`,\n        message: ``\n      },\n      {\n        button_size: `INVALID_BUTTON_SIZE`,\n        message: ``\n      }\n    ]  \n  },\n  {\n    text: `TEXT.`,\n    codes: [\n      {\n        several_h1: `SEVERAL_H1`,\n        message: ``\n      },\n      {\n        h2_position: `INVALID_H2_POSITION`,\n        message: ``\n      }\n    ]  \n  }\n];\n\nconst TEXT_SIZE_CODE = `TEXT_SIZES_SHOULD_BE_EQUAL`;\nconst TEXT_SIZE_ERROR = `Тексты в блоке warning должны быть одного размера`;\nconst BUTTON_SIZE_CODE = `INVALID_BUTTON_SIZE`;\nconst BUTTON_SIZE_ERROR = `Размер кнопки блока warning должен быть на 1 шаг больше эталонного`;\nconst BUTTON_POSITION_CODE = `INVALID_BUTTON_POSITION`;\nconst BUTTON_POSITION_ERROR = `Блок button в блоке warning не может находиться перед блоком placeholder на том же или более глубоком уровне вложенности`;\nconst PLACEHOLDER_SIZE_CODE = `INVALID_PLACEHOLDER_SIZE`;\nconst PLACEHOLDER_SIZE_ERROR = `Допустимые размеры для блока placeholder в блоке warning (значение модификатора size): s, m, l`;\nconst H1_SEVERAL_CODE = `SEVERAL_H1`;\nconst H1_SEVERAL_ERROR = `Заголовок первого уровня (блок text с модификатором type h1) на странице должен быть единственным`;\nconst H2_POSITION_CODE = `INVALID_H2_POSITION`;\nconst H2_POSITION_ERROR = `Заголовок второго уровня (блок text с модификатором type h2) не может находиться перед заголовком первого уровня на том же или более глубоком уровне вложенности`;\nconst H3_POSITION_CODE = `INVALID_H3_POSITION`;\nconst H3_POSITION_ERROR = `Заголовок третьего уровня (блок text с модификатором type h3) не может находиться перед заголовком второго уровня на том же или более глубоком уровне вложенности`;\n\nconst SIZES = [`xs`, `s`, `m`, `l`, `xl`];\nconst SIZES_PLACEHOLDER = [`s`, `m`, `l`];\n\nlet column = 0;\n\nlet errors = [];\n\nconst createErrorObject = (errorCode, errorMessage, errorLocationStart, errorLocationEnd) => {\n  const error = {\n    code: `${errorCode}`,\n    error: `${errorMessage}`,\n    location: {\n      start: {\n        column: 1,\n        line: 1\n      },\n      end: {\n        column: 2,\n        line: 22\n      },\n    },\n  };\n  return error;\n};\n\nconst findFirstElementIndex = (arr, blockName) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i].block === blockName) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n// const checkWarningPlaceholderSize = (contentArr) => {\n//   const placeholderIndex = findFirstElementIndex(contentArr, PLACEHOLDER_BLOCK);\n\n//   if (!SIZES_PLACEHOLDER.includes(contentArr[placeholderIndex].mods.size)) {\n//     return createErrorObject(WARNING_CODE + PLACEHOLDER_SIZE_CODE, PLACEHOLDER_SIZE_ERROR);\n//   }\n// };\n\n// const checkWarningButtonPosition = (contentArr) => {\n//   const firstPlaceholderElementIndex = findFirstElementIndex(contentArr, PLACEHOLDER_BLOCK);\n//   const firstButtonElementIndex = findFirstElementIndex(contentArr, BUTTON_BLOCK);\n\n//   if (firstButtonElementIndex < firstPlaceholderElementIndex) {\n//     return createErrorObject(WARNING_CODE + BUTTON_POSITION_CODE, BUTTON_POSITION_ERROR);\n//   }\n// };\n\n// const checkWarningButtonSize = (contentArr) => {\n//   const firstTextElementIndex = findFirstElementIndex(contentArr, TEXT_BLOCK);\n//   const firstButtonElementIndex = findFirstElementIndex(contentArr, BUTTON_BLOCK);\n//   const gauge = SIZES[SIZES.indexOf(contentArr[firstTextElementIndex].mods.size) + 1];\n\n//   if (contentArr[firstButtonElementIndex].mods.size !== gauge) {\n//     return createErrorObject(WARNING_CODE + BUTTON_SIZE_CODE, BUTTON_SIZE_ERROR);\n//   }\n// };\n\n// const checkWarningTextSize = (contentArr) => {\n//   const firstTextElementIndex = findFirstElementIndex(contentArr, TEXT_BLOCK);\n//   const gauge = contentArr[firstTextElementIndex].mods.size;\n\n//   for (let i = firstTextElementIndex + 1; i < contentArr.length; i++) {\n//     if (contentArr[i].mods.size !== gauge) {\n//       return createErrorObject(WARNING_CODE + TEXT_SIZE_CODE, TEXT_SIZE_ERROR);\n//     }\n//   }\n// };\n\nconst findFirstElementModsIndex = (arr, blockName, mod) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i].block === blockName && arr[i].mods.type === mod) {\n      return i;\n    }\n  }\n  return -1;\n};\n\nconst findH1 = (value) => {\n  if (value.block === TEXT_BLOCK && value.mods.type === HEADING_1_BLOCK) {\n    return 1;\n  }\n};\n\nconst checkTextH1Several = (contentArr) => {\n  if (contentArr.filter(findH1).length > 1) {\n    return createErrorObject(TEXT_CODE + H1_SEVERAL_CODE, H1_SEVERAL_ERROR);\n  }\n};\n\nconst checkTextH2Position = (contentArr) => {\n  const firstH1ElementIndex = findFirstElementModsIndex(contentArr, TEXT_BLOCK, HEADING_1_BLOCK);\n  const firstH2ElementIndex = findFirstElementModsIndex(contentArr, TEXT_BLOCK, HEADING_2_BLOCK);\n\n  if (firstH1ElementIndex > firstH2ElementIndex) {\n    return createErrorObject(TEXT_CODE + H2_POSITION_CODE, H2_POSITION_ERROR);\n  }\n};\n\nconst checkTextH3Position = (contentArr) => {\n  const firstH2ElementIndex = findFirstElementModsIndex(contentArr, TEXT_BLOCK, HEADING_2_BLOCK);\n  const firstH3ElementIndex = findFirstElementModsIndex(contentArr, TEXT_BLOCK, HEADING_3_BLOCK);\n\n  if (firstH3ElementIndex > firstH2ElementIndex) {\n    return createErrorObject(TEXT_CODE + H3_POSITION_CODE, H3_POSITION_ERROR);\n  }\n};\n\nconst warningTest = (warningBlock) => {\n  const warningObject = JSON.parse(warningBlock);\n\n  // console.log(errors);\n  \n  return errors;\n};\n\nexport {\n  SIZES,\n  SIZES_PLACEHOLDER,\n  warningTest,\n  createErrorObject,\n  findFirstElementIndex,\n  checkTextH1Several,\n  checkTextH2Position,\n  checkTextH3Position\n};\n\nimport {\n  createErrorObject\n} from './common';\n\nconst TEXT_CODE = `TEXT.`;\nconst TEXT_BLOCK = `text`;\nconst HEADING_1_BLOCK = `h1`;\nconst HEADING_2_BLOCK = `h2`;\nconst HEADING_3_BLOCK = `h3`;\n\nconst ERROR_CODES = [\n  {\n    warning: `WARNING.`,\n    codes: [\n      {\n        text_size: `TEXT_SIZES_SHOULD_BE_EQUAL`,\n        message: ``\n      },\n      {\n        button_size: `INVALID_BUTTON_SIZE`,\n        message: ``\n      }\n    ]  \n  },\n  {\n    text: `TEXT.`,\n    codes: [\n      {\n        several_h1: `SEVERAL_H1`,\n        message: ``\n      },\n      {\n        h2_position: `INVALID_H2_POSITION`,\n        message: ``\n      }\n    ]  \n  }\n];\n\nconst H1_SEVERAL_CODE = `SEVERAL_H1`;\nconst H1_SEVERAL_ERROR = `Заголовок первого уровня (блок text с модификатором type h1) на странице должен быть единственным`;\nconst H2_POSITION_CODE = `INVALID_H2_POSITION`;\nconst H2_POSITION_ERROR = `Заголовок второго уровня (блок text с модификатором type h2) не может находиться перед заголовком первого уровня на том же или более глубоком уровне вложенности`;\nconst H3_POSITION_CODE = `INVALID_H3_POSITION`;\nconst H3_POSITION_ERROR = `Заголовок третьего уровня (блок text с модификатором type h3) не может находиться перед заголовком второго уровня на том же или более глубоком уровне вложенности`;\n\nlet column = 0;\n\nlet errors = [];\n\nconst findFirstElementModsIndex = (arr, blockName, mod) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i].block === blockName && arr[i].mods.type === mod) {\n      return i;\n    }\n  }\n  return -1;\n};\n\nconst findH1 = (value) => {\n  if (value.block === TEXT_BLOCK && value.mods.type === HEADING_1_BLOCK) {\n    return 1;\n  }\n};\n\nconst checkTextH1Several = (contentArr) => {\n  if (contentArr.filter(findH1).length > 1) {\n    return createErrorObject(TEXT_CODE + H1_SEVERAL_CODE, H1_SEVERAL_ERROR);\n  }\n};\n\nconst checkTextH2Position = (contentArr) => {\n  const firstH1ElementIndex = findFirstElementModsIndex(contentArr, TEXT_BLOCK, HEADING_1_BLOCK);\n  const firstH2ElementIndex = findFirstElementModsIndex(contentArr, TEXT_BLOCK, HEADING_2_BLOCK);\n\n  if (firstH1ElementIndex > firstH2ElementIndex) {\n    return createErrorObject(TEXT_CODE + H2_POSITION_CODE, H2_POSITION_ERROR);\n  }\n};\n\nconst checkTextH3Position = (contentArr) => {\n  const firstH2ElementIndex = findFirstElementModsIndex(contentArr, TEXT_BLOCK, HEADING_2_BLOCK);\n  const firstH3ElementIndex = findFirstElementModsIndex(contentArr, TEXT_BLOCK, HEADING_3_BLOCK);\n\n  if (firstH3ElementIndex > firstH2ElementIndex) {\n    return createErrorObject(TEXT_CODE + H3_POSITION_CODE, H3_POSITION_ERROR);\n  }\n};\n\nexport {\n  checkTextH1Several,\n  checkTextH2Position,\n  checkTextH3Position\n};\n\nimport {\n  SIZES,\n  SIZES_PLACEHOLDER,\n  createErrorObject,\n  findFirstElementIndex\n} from './common';\n\nconst WARNING_CODE = `WARNING.`;\nconst TEXT_BLOCK = `text`;\nconst BUTTON_BLOCK = `button`;\nconst PLACEHOLDER_BLOCK = `placeholder`;\n\nconst TEXT_SIZE_CODE = `TEXT_SIZES_SHOULD_BE_EQUAL`;\nconst TEXT_SIZE_ERROR = `Тексты в блоке warning должны быть одного размера`;\nconst BUTTON_SIZE_CODE = `INVALID_BUTTON_SIZE`;\nconst BUTTON_SIZE_ERROR = `Размер кнопки блока warning должен быть на 1 шаг больше эталонного`;\nconst BUTTON_POSITION_CODE = `INVALID_BUTTON_POSITION`;\nconst BUTTON_POSITION_ERROR = `Блок button в блоке warning не может находиться перед блоком placeholder на том же или более глубоком уровне вложенности`;\nconst PLACEHOLDER_SIZE_CODE = `INVALID_PLACEHOLDER_SIZE`;\nconst PLACEHOLDER_SIZE_ERROR = `Допустимые размеры для блока placeholder в блоке warning (значение модификатора size): s, m, l`;\n\nconst checkWarningPlaceholderSize = (contentArr) => {\n  const placeholderIndex = findFirstElementIndex(contentArr, PLACEHOLDER_BLOCK);\n\n  if (!SIZES_PLACEHOLDER.includes(contentArr[placeholderIndex].mods.size)) {\n    return createErrorObject(WARNING_CODE + PLACEHOLDER_SIZE_CODE, PLACEHOLDER_SIZE_ERROR);\n  }\n};\n\nconst checkWarningButtonPosition = (contentArr) => {\n  const firstPlaceholderElementIndex = findFirstElementIndex(contentArr, PLACEHOLDER_BLOCK);\n  const firstButtonElementIndex = findFirstElementIndex(contentArr, BUTTON_BLOCK);\n\n  if (firstButtonElementIndex < firstPlaceholderElementIndex) {\n    return createErrorObject(WARNING_CODE + BUTTON_POSITION_CODE, BUTTON_POSITION_ERROR);\n  }\n};\n\nconst checkWarningButtonSize = (contentArr) => {\n  const firstTextElementIndex = findFirstElementIndex(contentArr, TEXT_BLOCK);\n  const firstButtonElementIndex = findFirstElementIndex(contentArr, BUTTON_BLOCK);\n  const gauge = SIZES[SIZES.indexOf(contentArr[firstTextElementIndex].mods.size) + 1];\n\n  if (contentArr[firstButtonElementIndex].mods.size !== gauge) {\n    return createErrorObject(WARNING_CODE + BUTTON_SIZE_CODE, BUTTON_SIZE_ERROR);\n  }\n};\n\nconst checkWarningTextSize = (contentArr) => {\n  const firstTextElementIndex = findFirstElementIndex(contentArr, TEXT_BLOCK);\n  const gauge = contentArr[firstTextElementIndex].mods.size;\n\n  for (let i = firstTextElementIndex + 1; i < contentArr.length; i++) {\n    if (contentArr[i].mods.size !== gauge) {\n      return createErrorObject(WARNING_CODE + TEXT_SIZE_CODE, TEXT_SIZE_ERROR);\n    }\n  }\n};\n\nexport {\n  checkWarningTextSize,\n  checkWarningButtonSize,\n  checkWarningButtonPosition,\n  checkWarningPlaceholderSize\n};"],"file":"linter.js"}